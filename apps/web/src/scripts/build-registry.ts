import path from 'path'
import { existsSync, promises as fs } from 'fs'
import { Registry } from '../registry/schema'

import { registry } from '../registry'

interface RegistryFile {
  path: string
}

interface RegistryItem {
  name: string
  files: RegistryFile[]
  dependencies?: string[]
  type?: string
}

interface OutputEntry {
  component: string
  source: string
  dependencies?: string[]
}

type Output = Record<string, OutputEntry>

async function buildComponentRegistryWithSourceCode(): Promise<void> {
  const output: Output = {}

  for (const item of registry.items) {
    const files = item.files
      ? await Promise.all(
          item.files.map(async (file) => {
            let content = await fs.readFile(
              path.join(__dirname, `../${file.path}`),
              'utf8'
            )
            // If the item is a hook, replace import paths
            if (item.type && item.type.startsWith('hooks')) {
              content = replaceImportPathForHook(content)
            }
            return { path: file.path, content }
          })
        )
      : []
    output[item.name] = {
      component:
        item.files && item.files[0]
          ? `() => import('../${item.files[0].path.replace('.tsx', '')}').then(mod => mod.${item.files[0].path.split('/').pop()!.replace('.tsx', '')})`
          : 'undefined',
      source: replaceImportPathForHook(files[0]?.content ?? ''),
      dependencies: item.dependencies,
    }
  }

  const registryString = JSON.stringify(output, null, 2)
  // Remove quotes around the component function string
  const finalRegistryString = registryString.replace(
    /"component": "(.*?)"/gs,
    (_, fn) => `"component": ${fn.replace(/\\"/g, '"')}`
  )

  await fs.writeFile(
    path.join(__dirname, '../registry/component-registry-with-source-code.tsx'),
    `
    /**
     * Hook Registry
     * This file is auto-generated. Do not edit manually.
     */
    export const registry = ${finalRegistryString};
    `
  )
  console.log('Registry built successfully!')
}

buildComponentRegistryWithSourceCode().catch(console.error)

function replaceImportPathForHook(code: string): string {
  return code.replace(/@\/registry\/hooks/g, '@/hooks')
}

const REGISTRY_PATH = path.join(process.cwd(), 'public/r')
if (!existsSync(REGISTRY_PATH)) {
  fs.mkdir(REGISTRY_PATH, { recursive: true }).catch(console.error)
}

const PUBLIC_REGISTRY_URL =
  process.env.NODE_ENV === 'production'
    ? 'https://shaddy-docs.vercel.app/r'
    : 'http://localhost:3000/r'

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`

  index += `
}
`

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry.items
    .filter((item) => ['registry:hook'].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === 'string'
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file

          return file
        }),
      }
    })
  const registryJson = JSON.stringify(items, null, 2)
  await fs.writeFile(
    path.join(REGISTRY_PATH, 'index.json'),
    registryJson,
    'utf8'
  )
}

buildRegistry(registry).catch((error) => {
  console.error('Error building registry:', error)
  process.exit(1)
})

async function syncRegistry() {
  // Copy the public/r directory to v4/public/r without triggering v4's build
  //   const wwwPublicR = path.resolve(process.cwd(), 'public/r')
  //   const v4PublicR = path.resolve(process.cwd(), '../v4/public/r')
  // Ensure the source directory exists
  //   if (!existsSync(wwwPublicR)) {
  //     await fs.mkdir(wwwPublicR, { recursive: true })
  //   }
  //   await fs.mkdir(v4PublicR, { recursive: true })
  // Copy files from www to v4
  //   await fs.cp(wwwPublicR, v4PublicR, { recursive: true })
}

async function buildHookJsonFiles(registry: Registry) {
  const hookDir = path.join(REGISTRY_PATH, 'hook')
  if (!existsSync(hookDir)) {
    await fs.mkdir(hookDir, { recursive: true })
  }

  const processedFiles = new Set<string>()
  const hookItems = registry.items.filter(
    (item) => item.type === 'registry:hook'
  )

  for (const item of hookItems) {
    // Find the second file (the hook implementation)
    const hookFile = item.files?.[1]
    if (hookFile) {
      const filePath = typeof hookFile === 'string' ? hookFile : hookFile.path
      if (processedFiles.has(filePath)) continue // Skip if already processed
      processedFiles.add(filePath)

      const absPath = path.join(__dirname, `../${filePath}`)
      const content = await fs.readFile(absPath, 'utf8')
      const fileName = path.basename(filePath)

      // Find all registry items that use this hook file
      const relatedItems = hookItems.filter(
        (i) =>
          i.files?.[1] &&
          (typeof i.files[1] === 'string' ? i.files[1] : i.files[1].path) ===
            filePath
      )

      // Collect registryDependencies from all related items
      const registryDependencies = Array.from(
        new Set(
          relatedItems
            .flatMap((i) => i.registryDependencies ?? [])
            .map((dep) => `${PUBLIC_REGISTRY_URL}/hook/${dep}.json`)
        )
      )

      const json = {
        name: fileName.replace(/\.[^/.]+$/, ''), // use filename without extension
        type: 'registry:hook',
        ...(registryDependencies.length > 0 ? { registryDependencies } : {}),
        files: [
          {
            path: filePath,
            type: 'registry:hook',
            target: `hook/${fileName}`,
            content,
          },
        ],
        dependencies: relatedItems[0]?.dependencies,
        devDependencies: relatedItems[0]?.devDependencies,
      }
      const outFile = path.join(
        hookDir,
        `${fileName.replace(/\.[^/.]+$/, '')}.json`
      )
      await fs.writeFile(outFile, JSON.stringify(json, null, 2), 'utf8')
    }
  }
}

// Call this after buildRegistry
buildRegistry(registry)
  .then(() => buildHookJsonFiles(registry))
  .catch((error) => {
    console.error('Error building registry:', error)
    process.exit(1)
  })

// try {
//   console.log('ðŸ’½ Building registry...')
//   const result = registrySchema.safeParse(registry)

//   console.log({ result })

//   if (!result.success) {
//     console.error(result.error)
//     process.exit(1)
//   }

//   await buildRegistry(result.data)

//   console.log('ðŸ”„ Syncing registry...')
//   await syncRegistry()

//   console.log('âœ… Done!')
//   process.exit(0)
// } catch (error) {
//   console.error(error)
//   process.exit(1)
// }
