import { existsSync, promises as fs } from 'fs'
import { tmpdir } from 'os'
import path from 'path'
import { rimraf } from 'rimraf'

import { Project, ScriptKind } from 'ts-morph'
import { z } from 'zod'

import { registry } from '../registry'
import { registryCategories } from '../registry/registry-categories'
import { styles } from '../registry/registry-styles'
import { fixImport } from './fix-import'
import {
  Registry,
  registryItemSchema,
  registryItemTypeSchema,
  registrySchema,
} from '@/registry/schema'

const REGISTRY_PATH = path.join(process.cwd(), 'public/r')

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  'registry:ui',
  'registry:lib',
  'registry:hook',
  'registry:theme',
  'registry:block',
  'registry:example',
  'registry:internal',
]

const project = new Project({
  compilerOptions: {},
})

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), 'shadcn-'))
  return path.join(dir, filename)
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`

  for (const style of styles) {
    index += `  "${style.name}": {`

    // Build style index.
    for (const item of registry.items) {
      const resolveFiles = item.files?.map(
        (file) =>
          `registry/${style.name}/${
            typeof file === 'string' ? file : file.path
          }`
      )
      if (!resolveFiles) {
        continue
      }

      // Validate categories.
      if (item.categories) {
        const invalidCategories = item.categories.filter(
          (category) => !registryCategories.some((c) => c.slug === category)
        )

        if (invalidCategories.length > 0) {
          console.error(
            `${item.name} has invalid categories: ${invalidCategories}`
          )
          process.exit(1)
        }
      }

      const type = item.type.split(':')[1]
      let sourceFilename = ''

      if (item.type === 'registry:block') {
        const file = resolveFiles[0] as string
        const filename = path.basename(file)
        let raw: string
        try {
          raw = await fs.readFile(file, 'utf8')
        } catch (error) {
          continue
        }
        const tempFile = await createTempSourceFile(filename)
        const sourceFile = project.createSourceFile(tempFile, raw, {
          scriptKind: ScriptKind.TSX,
        })

        // Find all imports.
        const imports = new Map<
          string,
          {
            module: string
            text: string
            isDefault?: boolean
          }
        >()
        sourceFile.getImportDeclarations().forEach((node) => {
          const module = node.getModuleSpecifier().getLiteralValue()
          node.getNamedImports().forEach((item) => {
            imports.set(item.getText(), {
              module,
              text: node.getText(),
            })
          })

          const defaultImport = node.getDefaultImport()
          if (defaultImport) {
            imports.set(defaultImport.getText(), {
              module,
              text: defaultImport.getText(),
              isDefault: true,
            })
          }
        })

        // Write the source file for blocks only.
        sourceFilename = `src/__registry__/${style.name}/${type}/${item.name}.tsx`

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === 'string'
              ? { type: 'registry:page', path: file }
              : file
          )
          if (files?.length) {
            sourceFilename = `src/__registry__/${style.name}/${files[0]?.path}`
          }
        }

        const sourcePath = path.join(process.cwd(), sourceFilename)
        if (!existsSync(path.dirname(sourcePath))) {
          await fs.mkdir(path.dirname(sourcePath), { recursive: true })
        }

        if (existsSync(sourcePath)) {
          rimraf.sync(sourcePath)
        }
        await fs.writeFile(sourcePath, sourceFile.getText())
      }

      let componentPath = `@/registry/${style.name}/${type}/${item.name}`

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === 'string'
            ? { type: 'registry:page', path: file }
            : file
        )
        if (files?.length) {
          componentPath = `@/registry/${style.name}/${files[0]?.path}`
        }
      }

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ''}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `registry/${style.name}/${
          typeof file === 'string' ? file : file.path
        }`
        const resolvedFilePath = path.resolve(filePath)
        return typeof file === 'string'
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ''}"
      }`
      })}],
      categories: ${JSON.stringify(item.categories)},
      component: React.lazy(() => import("${componentPath}")),
      source: "${sourceFilename}",
      meta: ${JSON.stringify(item.meta)},
    },`
    }

    index += `
  },`
  }

  index += `
}
`

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry.items
    .filter((item) => ['registry:ui', 'registry:hook'].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === 'string'
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file

          return file
        }),
      }
    })
  const registryJson = JSON.stringify(items, null, 2)

  // Create directory if it doesn't exist
  if (!existsSync(REGISTRY_PATH)) {
    await fs.mkdir(REGISTRY_PATH, { recursive: true })
  }

  // Only remove if it exists
  const indexJsonPath = path.join(REGISTRY_PATH, 'index.json')
  if (existsSync(indexJsonPath)) {
    rimraf.sync(indexJsonPath)
  }
  await fs.writeFile(indexJsonPath, registryJson, 'utf8')

  // Create __registry__ directory if it doesn't exist and write style index
  const registryIndexPath = path.join(
    process.cwd(),
    'src/__registry__/index.tsx'
  )
  if (!existsSync(path.dirname(registryIndexPath))) {
    await fs.mkdir(path.dirname(registryIndexPath), { recursive: true })
  }

  // Only remove if it exists
  if (existsSync(registryIndexPath)) {
    rimraf.sync(registryIndexPath)
  }
  await fs.writeFile(registryIndexPath, index)
}

// ----------------------------------------------------------------------------
// Build registry/styles/[style]/[name].json.
// ----------------------------------------------------------------------------
async function buildStyles(registry: Registry) {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, 'styles', style.name)

    // Create directory if it doesn't exist.
    if (!existsSync(targetPath)) {
      await fs.mkdir(targetPath, { recursive: true })
    }

    for (const item of registry.items) {
      if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
        continue
      }

      let files
      if (item.files) {
        files = await Promise.all(
          item.files.map(async (_file) => {
            const file =
              typeof _file === 'string'
                ? {
                    path: _file,
                    type: item.type,
                    content: '',
                    target: '',
                  }
                : _file

            let content: string
            try {
              content = await fs.readFile(
                path.join(process.cwd(), 'src/registry', style.name, file.path),
                'utf8'
              )

              // Only fix imports for v0- blocks.
              if (item.name.startsWith('v0-')) {
                content = fixImport(content)
              }
            } catch (error) {
              return
            }

            const tempFile = await createTempSourceFile(file.path)
            const sourceFile = project.createSourceFile(tempFile, content, {
              scriptKind: ScriptKind.TSX,
            })

            sourceFile.getVariableDeclaration('iframeHeight')?.remove()
            sourceFile.getVariableDeclaration('containerClassName')?.remove()
            sourceFile.getVariableDeclaration('description')?.remove()

            let target = file.target || ''

            if ((!target || target === '') && item.name.startsWith('v0-')) {
              const fileName = file.path.split('/').pop()
              if (
                file.type === 'registry:block' ||
                file.type === 'registry:component' ||
                file.type === 'registry:example'
              ) {
                target = `components/${fileName}`
              }

              if (file.type === 'registry:ui') {
                target = `components/ui/${fileName}`
              }

              if (file.type === 'registry:hook') {
                target = `hooks/${fileName}`
              }

              if (file.type === 'registry:lib') {
                target = `lib/${fileName}`
              }
            }

            return {
              path: file.path,
              type: file.type,
              content: sourceFile.getText(),
              target,
            }
          })
        )
      }

      const payload = registryItemSchema.safeParse({
        $schema: 'https://ui.shadcn.com/schema/registry-item.json',
        author: 'shadcn (https://ui.shadcn.com)',
        ...item,
        files,
      })

      if (payload.success) {
        await fs.writeFile(
          path.join(targetPath, `${item.name}.json`),
          JSON.stringify(payload.data, null, 2),
          'utf8'
        )
      }
    }
  }

  // ----------------------------------------------------------------------------
  // Build registry/styles/index.json.
  // ----------------------------------------------------------------------------
  const stylesJson = JSON.stringify(styles, null, 2)
  await fs.writeFile(
    path.join(REGISTRY_PATH, 'styles/index.json'),
    stylesJson,
    'utf8'
  )
}

// ----------------------------------------------------------------------------
// Build registry/styles/[name]/index.json.
// ----------------------------------------------------------------------------
async function buildStylesIndex() {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, 'styles', style.name)

    const payload: z.infer<typeof registryItemSchema> = {
      name: style.name,
      type: 'registry:style',
      dependencies: [
        'tailwindcss-animate',
        'class-variance-authority',
        'lucide-react',
      ],
      registryDependencies: ['utils'],
      tailwind: {
        config: {
          plugins: [`require("tailwindcss-animate")`],
        },
      },
      cssVars: {},
      files: [],
    }

    await fs.writeFile(
      path.join(targetPath, 'index.json'),
      JSON.stringify(payload, null, 2),
      'utf8'
    )
  }
}

async function syncRegistry() {
  // Copy the public/r directory to v4/public/r without triggering v4's build
  const wwwPublicR = path.resolve(process.cwd(), 'public/r')
  const v4PublicR = path.resolve(process.cwd(), '../v4/public/r')

  // Ensure the source directory exists
  if (!existsSync(wwwPublicR)) {
    await fs.mkdir(wwwPublicR, { recursive: true })
  }

  // Clean and recreate the v4/public/r directory
  rimraf.sync(v4PublicR)
  await fs.mkdir(v4PublicR, { recursive: true })

  // Copy files from www to v4
  await fs.cp(wwwPublicR, v4PublicR, { recursive: true })
}

async function main() {
  try {
    console.log('💽 Building registry...')
    const result = registrySchema.safeParse(registry)

    if (!result.success) {
      console.error(result.error)
      process.exit(1)
    }

    // await syncStyles() // Skip since we only have default style
    await buildRegistry(result.data)
    await buildStyles(result.data)
    await buildStylesIndex()
    // await buildThemes() // Comment out if function doesn't exist

    console.log('🔄 Syncing registry...')
    await syncRegistry()

    console.log('✅ Done!')
    process.exit(0)
  } catch (error) {
    console.error(error)
    process.exit(1)
  }
}

main()
