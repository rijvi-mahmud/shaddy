import path from 'path'
import { existsSync, promises as fs } from 'fs'
import { Registry } from '../registry/schema'

import { registry } from '../registry'

interface RegistryFile {
  path: string
}

interface RegistryItem {
  name: string
  files: RegistryFile[]
  dependencies?: string[]
  type?: string
}

interface OutputEntry {
  component: string
  source: string
  dependencies?: string[]
}

type Output = Record<string, OutputEntry>

async function buildComponentRegistryWithSourceCode(): Promise<void> {
  const output: Output = {}

  for (const item of registry.items) {
    const files = item.files
      ? await Promise.all(
          item.files.map(async (file) => {
            let content = await fs.readFile(
              path.join(__dirname, `../${file.path}`),
              'utf8'
            )
            // If the item is a hook, replace import paths
            if (item.type && item.type.startsWith('hooks')) {
              content = replaceImportPath(content)
            }
            return { path: file.path, content }
          })
        )
      : []
    output[item.name] = {
      component:
        item.files && item.files[0]
          ? `() => import('../${item.files[0].path.replace('.tsx', '')}').then(mod => mod.${item.files[0].path.split('/').pop()!.replace('.tsx', '')})`
          : 'undefined',
      source: replaceImportPath(files[0]?.content ?? ''),
      dependencies: item.dependencies,
    }
  }

  const registryString = JSON.stringify(output, null, 2)
  // Remove quotes around the component function string
  const finalRegistryString = registryString.replace(
    /"component": "(.*?)"/gs,
    (_, fn) => `"component": ${fn.replace(/\\"/g, '"')}`
  )

  await fs.writeFile(
    path.join(__dirname, '../registry/component-registry-with-source-code.tsx'),
    `
    /**
     * Hook Registry
     * This file is auto-generated. Do not edit manually.
     */
    export const registry = ${finalRegistryString};
    `
  )
  console.log('Registry built successfully!')
}

buildComponentRegistryWithSourceCode().catch(console.error)

function replaceImportPath(code: string): string {
  return code
    .replace(/@\/registry\/shaddyForm/g, '@/components/shaddy-form')
    .replace(/@\/registry\/hooks/g, '@/hooks')
}

const REGISTRY_PATH = path.join(process.cwd(), 'public/r')
if (!existsSync(REGISTRY_PATH)) {
  fs.mkdir(REGISTRY_PATH, { recursive: true }).catch(console.error)
}

const PUBLIC_REGISTRY_URL =
  process.env.NODE_ENV === 'production'
    ? 'https://shaddy-docs.vercel.app/r'
    : 'http://localhost:3000/r'

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`

  index += `
}
`

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry.items
    .filter((item) => ['registry:hook'].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === 'string'
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file

          return file
        }),
      }
    })
  const registryJson = JSON.stringify(items, null, 2)
  await fs.writeFile(
    path.join(REGISTRY_PATH, 'index.json'),
    registryJson,
    'utf8'
  )
}

buildRegistry(registry).catch((error) => {
  console.error('Error building registry:', error)
  process.exit(1)
})

// async function syncRegistry() {
//   // Copy the public/r directory to v4/public/r without triggering v4's build
//   //   const wwwPublicR = path.resolve(process.cwd(), 'public/r')
//   //   const v4PublicR = path.resolve(process.cwd(), '../v4/public/r')
//   // Ensure the source directory exists
//   //   if (!existsSync(wwwPublicR)) {
//   //     await fs.mkdir(wwwPublicR, { recursive: true })
//   //   }
//   //   await fs.mkdir(v4PublicR, { recursive: true })
//   // Copy files from www to v4
//   //   await fs.cp(wwwPublicR, v4PublicR, { recursive: true })
// }

type BuildJsonFilesOptions = {
  dirName: string
  itemType: string
  fileType: string
  targetPrefix: string
  registryDepUrl: (dep: string) => string
}

async function buildRegistryJsonFiles(
  registry: Registry,
  options: BuildJsonFilesOptions
) {
  const dir = path.join(REGISTRY_PATH, options.dirName)
  if (!existsSync(dir)) {
    await fs.mkdir(dir, { recursive: true })
  }

  const processedFiles = new Set<string>()
  const items = registry.items.filter((item) => item.type === options.itemType)

  for (const item of items) {
    const file = item.files?.[1]
    if (file) {
      // Support both string and object file definitions
      const fileObj = typeof file === 'string' ? { path: file } : file
      const filePath = fileObj.path
      if (processedFiles.has(filePath)) continue
      processedFiles.add(filePath)

      const absPath = path.join(__dirname, `../${filePath}`)
      const content = await fs.readFile(absPath, 'utf8')
      const fileName = path.basename(filePath)

      const relatedItems = items.filter(
        (i) =>
          i.files?.[1] &&
          (typeof i.files[1] === 'string' ? i.files[1] : i.files[1].path) ===
            filePath
      )

      const registryDependencies = Array.from(
        new Set(
          relatedItems
            .flatMap((i) => i.registryDependencies ?? [])
            .map(options.registryDepUrl)
        )
      )

      const json = {
        name: fileName.replace(/\.[^/.]+$/, ''),
        type: options.itemType,
        ...(registryDependencies.length > 0 ? { registryDependencies } : {}),
        files: [
          {
            path: filePath,
            type: options.fileType,
            // Use the target from fileObj if present, otherwise fallback
            target:
              'target' in fileObj && typeof fileObj.target === 'string'
                ? fileObj.target
                : `${options.targetPrefix}${fileName}`,
            content,
          },
        ],
        dependencies: relatedItems[0]?.dependencies,
        devDependencies: relatedItems[0]?.devDependencies,
      }
      const outFile = path.join(
        dir,
        `${fileName.replace(/\.[^/.]+$/, '')}.json`
      )
      await fs.writeFile(outFile, JSON.stringify(json, null, 2), 'utf8')
    }
  }
}

// Replace the old functions with these calls:
buildRegistry(registry)
  .then(() => {
    buildRegistryJsonFiles(registry, {
      dirName: 'hooks',
      itemType: 'registry:hook',
      fileType: 'registry:hook',
      targetPrefix: 'hooks/',
      registryDepUrl: (dep) => `${PUBLIC_REGISTRY_URL}/hooks/${dep}.json`,
    })
    buildRegistryJsonFiles(registry, {
      dirName: 'shaddyForm',
      itemType: 'registry:component',
      fileType: 'registry:component',
      targetPrefix: 'components/shaddy-form/',
      registryDepUrl: (dep) =>
        dep.endsWith(':ui')
          ? `${PUBLIC_REGISTRY_URL}/components/${dep.replace(':ui', '')}.json`
          : dep.endsWith(':local')
            ? `${PUBLIC_REGISTRY_URL}/shaddyForm/${dep.replace(':local', '')}.json`
            : dep,
    })
    buildRegistryJsonFiles(registry, {
      dirName: 'components',
      itemType: 'registry:ui',
      fileType: 'registry:ui',
      targetPrefix: 'components/ui/',
      registryDepUrl: (dep) =>
        dep.endsWith(':ui')
          ? `${PUBLIC_REGISTRY_URL}/components/${dep.replace(':ui', '')}.json`
          : dep.endsWith(':local')
            ? `${PUBLIC_REGISTRY_URL}/components/${dep.replace(':local', '')}.json`
            : dep,
    })
  })
  .catch((error) => {
    console.error('Error building registry:', error)
    process.exit(1)
  })

// try {
//   console.log('ðŸ’½ Building registry...')
//   const result = registrySchema.safeParse(registry)

//   console.log({ result })

//   if (!result.success) {
//     console.error(result.error)
//     process.exit(1)
//   }

//   await buildRegistry(result.data)

//   console.log('ðŸ”„ Syncing registry...')
//   await syncRegistry()

//   console.log('âœ… Done!')
//   process.exit(0)
// } catch (error) {
//   console.error(error)
//   process.exit(1)
// }
