{
  "$schema": "",
  "name": "use-debounced-callback",
  "type": "registry:hook",
  "author": "shaddy (https://shaddy-docs.vercel.app/)",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "hooks/use-debounced-callback.ts",
      "content": "import { useEffect, useMemo, useRef } from 'react'\n\n/**\n * Options for configuring the debounced callback behavior\n */\ntype DebounceOptions = {\n  /**\n   * Execute on the leading edge (immediately on first call)\n   * - When true: The function executes immediately on the first call\n   * - When false: The function waits for the full delay before executing\n   * - Example: Set to true for immediate feedback on first interaction\n   */\n  leading?: boolean\n\n  /**\n   * Execute on the trailing edge (after delay when input stops)\n   * - When true: The function executes after waiting for the delay when input stops\n   * - When false: The function won't execute after the delay\n   * - Default is true - this is the standard debounce behavior most people expect\n   */\n  trailing?: boolean\n\n  /**\n   * Maximum wait time before forcing execution\n   * - Forces the function to execute after this time even if input continues\n   * - Measured in milliseconds\n   * - Example: Set to 2000 to ensure execution happens at least every 2 seconds\n   *   during continuous input\n   */\n  maxWait?: number // Maximum time to wait before forcing execution\n}\n\n/**\n * Control functions for managing the debounced callback\n */\ntype ControlFunctions = {\n  cancel: () => void // Cancel any pending executions\n  flush: () => void // Immediately execute any pending callback\n  isPending: () => boolean // Check if a callback execution is pending\n}\n\n/**\n * Combined type for the debounced function with attached control methods\n */\nexport type DebouncedFunction<T extends (...args: any[]) => any> = ((\n  ...args: Parameters<T>\n) => ReturnType<T> | undefined) &\n  ControlFunctions\n\n/**\n * Custom hook to debounce a callback function with enhanced control functions.\n *\n * @template T - The type of the callback function.\n * @param {T} callback - The callback function to debounce.\n * @param {number} delay - The delay in milliseconds before executing the callback.\n * @param {DebounceOptions} options - Additional debounce configuration options.\n * @returns {DebouncedFunction<T>} - The debounced callback function with control methods.\n *\n * @example\n * const handleSearch = (query: string) => {\n *   // search logic here\n *   return searchResults;\n * };\n * const debouncedSearch = useDebouncedCallback(handleSearch, 500);\n *\n * // Usage\n * debouncedSearch(\"search term\"); // Will execute after 500ms of inactivity\n * debouncedSearch.cancel();       // Cancels any pending execution\n * debouncedSearch.flush();        // Immediately executes any pending callback\n * if (debouncedSearch.isPending()) { showLoadingIndicator(); }\n */\nexport const useDebouncedCallback = <T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number = 300,\n  options?: DebounceOptions\n): DebouncedFunction<T> => {\n  const callbackRef = useRef(callback)\n  const timeoutRef = useRef<NodeJS.Timeout>(undefined)\n  const lastArgsRef = useRef<Parameters<T>>(undefined)\n  const lastCallTimeRef = useRef<number>(0)\n\n  /** Update callback ref when callback changes */\n  useEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n\n  /** Cleanup on unmount */\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n    }\n  }, [])\n\n  const debounced = useMemo(() => {\n    /**\n     * Executes the callback with the most recent arguments.\n     * Clears argument references and timeout after execution.\n     * @returns The result of the callback function or undefined\n     */\n    const invokeFunc = () => {\n      if (lastArgsRef.current) {\n        const result = callbackRef.current(...lastArgsRef.current)\n        lastArgsRef.current = undefined\n        timeoutRef.current = undefined\n        return result\n      }\n    }\n\n    /**\n     * Core debounce implementation that manages the timing of callback execution.\n     * Handles both immediate (leading edge) and delayed (trailing edge) invocation.\n     * @param args - Arguments to pass to the callback function\n     * @returns Result from immediate execution or undefined for delayed execution\n     */\n    const debouncedFn = (...args: Parameters<T>): ReturnType<T> | undefined => {\n      const currentTime = Date.now()\n      const isInvoking = shouldInvoke(currentTime)\n\n      // Store arguments for later execution\n      lastArgsRef.current = args\n      lastCallTimeRef.current = currentTime\n\n      // Handle leading edge execution (immediate)\n      if (isInvoking && options?.leading) {\n        return invokeFunc()\n      }\n\n      // Reset existing timer if present\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n\n      // Schedule delayed execution (trailing edge)\n      timeoutRef.current = setTimeout(\n        () => {\n          // Execute callback if trailing edge is enabled (default behavior)\n          const shouldTrail = options?.trailing !== false\n          if (shouldTrail) {\n            invokeFunc()\n          }\n\n          // Reset call time to prepare for next debounce cycle\n          lastCallTimeRef.current = 0\n\n          // Clear the timeout reference to indicate no pending execution\n          timeoutRef.current = undefined\n        },\n        Math.max(0, delay)\n      )\n    }\n\n    function shouldInvoke(time: number): boolean {\n      const timeSinceLastCall = time - lastCallTimeRef.current\n\n      return (\n        lastCallTimeRef.current === 0 || // First call (leading edge)\n        timeSinceLastCall >= delay || // Standard debounce period elapsed (trailing edge)\n        (options?.maxWait !== undefined && timeSinceLastCall >= options.maxWait) // Force execution after maxWait\n      )\n    }\n\n    // Attach control methods\n    const controlledFn = debouncedFn as DebouncedFunction<T>\n\n    controlledFn.cancel = () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n        lastArgsRef.current = undefined\n        timeoutRef.current = undefined\n      }\n    }\n\n    controlledFn.flush = () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n\n        return invokeFunc()\n      }\n    }\n\n    controlledFn.isPending = () => {\n      return !!timeoutRef.current\n    }\n\n    return controlledFn\n  }, [delay, options?.leading, options?.trailing, options?.maxWait])\n\n  return debounced\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-debounced-callback.ts"
    }
  ]
}
