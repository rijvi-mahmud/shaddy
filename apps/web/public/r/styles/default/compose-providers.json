{
  "$schema": "",
  "name": "compose-providers",
  "type": "registry:lib",
  "author": "shaddy (https://shaddy-docs.vercel.app/)",
  "dependencies": ["lucide-react"],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "utils/compose-providers.ts",
      "content": "import { createElement, Fragment } from 'react'\n\ntype ComponentAndProps<P> = [React.ComponentType<P>, P]\ntype ProviderConfig<P = any> = React.ComponentType<P> | ComponentAndProps<P>\n\ntype ProvidersTuple = readonly ProviderConfig<any>[]\n\ninterface ComposeProviders {\n  <T extends ProvidersTuple>(\n    providers: T,\n    displayName?: string\n  ): React.FC<React.PropsWithChildren<{}>>\n}\n\nexport const composeProviders: ComposeProviders = (\n  providers: ProvidersTuple,\n  displayName?: string\n) => {\n  // Create a reversed copy of providers to ensure the first provider in the array becomes the outermost wrapper.\n  // This avoids mutating the original array and preserves intuitive nesting order.\n  const reversedProviders = providers.slice().reverse()\n  function Composed(props: React.PropsWithChildren<{}>) {\n    return reversedProviders.reduce<React.ReactElement>(\n      (children, provider) => {\n        if (Array.isArray(provider)) {\n          const [Provider, providerProps] = provider\n          return createElement(Provider, providerProps, children)\n        }\n        const Provider = provider\n        return createElement(Provider, null, children)\n      },\n      createElement(Fragment, null, props.children)\n    )\n  }\n  Composed.displayName = displayName\n  return Composed\n}\n",
      "type": "registry:lib",
      "target": "utils/compose-providers.ts"
    }
  ]
}
