{
  "$schema": "",
  "name": "use-local-storage",
  "type": "registry:hook",
  "author": "shaddy (https://shaddy-docs.vercel.app/)",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "hooks/use-local-storage.ts",
      "content": "import {\n  useCallback,\n  useState,\n  type Dispatch,\n  type SetStateAction,\n} from 'react'\nimport { useEventListener } from '@/registry/default/hooks/use-event-listener'\n\n/**\n * Configuration options for the useLocalStorage hook.\n * @template T - The type of the value to store.\n */\ntype UseLocalStorageOptions<T> = {\n  /** Custom serializer function to convert value to string. Defaults to JSON.stringify. */\n  serializer?: (value: T) => string\n  /** Custom deserializer function to convert string to value. Defaults to JSON.parse. */\n  deserializer?: (value: string) => T\n  /** Whether to initialize with value from localStorage on mount. Defaults to true. */\n  initializeWithValue?: boolean\n  /** Error handler function called when localStorage operations fail. */\n  onError?: (error: Error, key: string) => void\n}\n\n/**\n * Hook to manage a value in localStorage with optional serialization and deserialization.\n *\n * @template T - The type of the value to store.\n * @param {string} key - The key to store the value under in localStorage.\n * @param {T | (() => T)} [initialValue] - The initial value or a function to compute it.\n * @param {UseLocalStorageOptions<T>} [options] - Optional configuration for serialization, deserialization, and initialization.\n * @returns {[T, Dispatch<SetStateAction<T>>, () => void]} - The stored value, a setter function, and a remover function.\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T | (() => T) = undefined as T,\n  options: UseLocalStorageOptions<T> = {}\n): [T, Dispatch<SetStateAction<T>>, () => void] {\n  const {\n    initializeWithValue = true,\n    serializer = JSON.stringify,\n    deserializer = JSON.parse,\n    onError = (error, key) =>\n      console.warn(`Error with localStorage key \"${key}\": ${error.message}`),\n  } = options\n\n  const isLocalStorageAvailable = useCallback((): boolean => {\n    return typeof window !== 'undefined' && !!window.localStorage\n  }, [])\n\n  const getInitialValue = useCallback((): T => {\n    if (typeof initialValue === 'function') {\n      return (initialValue as () => T)()\n    }\n    return initialValue\n  }, [initialValue])\n\n  const readValueFromStorage = useCallback((): T => {\n    if (!isLocalStorageAvailable()) {\n      return getInitialValue()\n    }\n\n    try {\n      const storedItem = window.localStorage.getItem(key)\n\n      if (storedItem === null) {\n        return getInitialValue()\n      }\n\n      return deserializer(storedItem)\n    } catch (error) {\n      const errorObj =\n        error instanceof Error ? error : new Error('Unknown error')\n      onError(errorObj, key)\n      return getInitialValue()\n    }\n  }, [key, deserializer, onError, isLocalStorageAvailable, getInitialValue])\n\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    if (initializeWithValue) {\n      return readValueFromStorage()\n    }\n    return getInitialValue()\n  })\n\n  /** Function to update localStorage and state with error handling. */\n  const setValue: Dispatch<SetStateAction<T>> = useCallback(\n    (value) => {\n      if (!isLocalStorageAvailable()) {\n        onError(new Error('localStorage not available'), key)\n        return\n      }\n\n      try {\n        const newValue =\n          typeof value === 'function'\n            ? (value as (prev: T) => T)(storedValue)\n            : value\n\n        window.localStorage.setItem(key, serializer(newValue))\n        setStoredValue(newValue)\n      } catch (error) {\n        const errorObj =\n          error instanceof Error ? error : new Error('Unknown error')\n        onError(errorObj, key)\n      }\n    },\n    [key, storedValue, serializer, onError, isLocalStorageAvailable]\n  )\n\n  /** Function to remove value from localStorage and reset state to initial value. */\n  const removeValue = useCallback(() => {\n    if (isLocalStorageAvailable()) {\n      window.localStorage.removeItem(key)\n    }\n\n    setStoredValue(getInitialValue())\n  }, [key, isLocalStorageAvailable, getInitialValue])\n\n  /** Handle storage events from other tabs/windows when our key changes. */\n  const handleStorageChange = useCallback(\n    (event: StorageEvent) => {\n      if (event.key === key) {\n        setStoredValue(readValueFromStorage())\n      }\n    },\n    [key, readValueFromStorage]\n  )\n\n  /** Listen for storage changes from other tabs/windows using the custom hook. */\n  useEventListener(\n    'storage',\n    handleStorageChange,\n    typeof window !== 'undefined' ? window : null\n  )\n\n  return [storedValue, setValue, removeValue]\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-local-storage.ts"
    }
  ]
}
